# cdc-sample

## Abstract

This reference architecture presents a scalable solution for real-time data synchronization from an Oracle database to
Apache Kafka using Kafka Connect JDBC or Debezium. The solution captures changes from the database using triggers that
populate a CHANGE_TRACKING table, which Kafka Connect polls to stream events to Kafka topics. This architecture enables
seamless integration with downstream systems and supports event-driven microservices. The document includes
architectural
diagrams, SQL scripts, trigger logic, a step-by-step validation guide, and Kafka Connect configuration for end-to-end
implementation.

## Architecture Diagram

         ┌──────────────────────────┐
         │      Oracle Database     │
         │ ┌──────────────────────┐ │
         │ │  Application Tables  │ │
         │ └──────────────────────┘ │
         │            ▲             │
         │            │ (Trigger)   │
         │            ▼             │
         │ ┌──────────────────────┐ │
         │ │   CHANGE_TRACKING    │ │
         │ └──────────────────────┘ │
         └───────────┬──────────────┘
                     │ (CDC Polling)
                     ▼
        ┌──────────────────────────┐
        │     Kafka Connect        │
        │  (JDBC or Debezium CDC)  │
        └───────────┬──────────────┘
                     │ (JSON Events)
                     ▼
        ┌──────────────────────────┐
        │        Kafka Broker      │
        │ (Topic: oracle_events)   │
        └───────────┬──────────────┘
                     │
        ┌───────────▼────────────┐
        │     Kafka Consumers    │
        │ (External Systems/APIs)│
        └────────────────────────┘

## How to set up oracledb using docker

1. In a web browser, sign in to the Oracle Container Registry using an Oracle account
   at https://container-registry.oracle.com.

2. Select the profile name. Select the profile name, and in the profile menu that appears select **Auth Token**.

3. Generate the **Secret Key**. Select Generate Secret Key and note down the secret key. This is only displayed once,
   during the initial generation.

4. (Optional) Regenerate the Secret Key. If you lose or forget the secret key, generate a new one by selecting Delete
   Secret Key, then select Generate Secret Key again.

5. Navigate to `database -> express` and accept the license agreement.

### Docker login

```bash
   docker login container-registry.oracle.com -u your-email@example.com
   # Enter the auth token when prompted for password
```

### Pull the image

```bash
  docker pull --platform=linux/amd64  container-registry.oracle.com/database/express:latest
```

### Run docker-compose

```bash
  docker-compose up -d
```

### Connection details

| Item        | Value                 |
|-------------|-----------------------|
| Host        | `localhost`           |
| Port        | `1521`                |
| SID/Service | `XEPDB1` or `XE`      |
| Username    | `SYSTEM`              |
| Password    | `MySecurePassword123` |

| Field            | Value                                                    |
|------------------|----------------------------------------------------------|
| **Host**         | `localhost`                                              |
| **Port**         | `1521`                                                   |
| **Service Name** | `XEPDB1` (for 21c XE)                                    |
| **SID**          | `XE` (if you’re using SID-style connection)              |
| **Username**     | `SYSTEM`                                                 |
| **Password**     | `MySecurePassword123` (as per your `docker-compose.yml`) |

### Connect using SQL Developer (GUI)

1. Download and open [Oracle SQL Developer](https://www.oracle.com/tools/downloads/sqldev-downloads.html).
2. Create a new connection:

    * **Username**: `SYSTEM`
    * **Password**: `MySecurePassword123`
    * **Hostname**: `localhost`
    * **Port**: `1521`
    * **Service name**: `XEPDB1` (not SID)
3. Click **Test**, then **Connect**.

---

## Database set up

### 1. Create ORDERS Table

``` sql
CREATE TABLE ORDERS (
  ORDER_ID        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  CUSTOMER_ID     NUMBER NOT NULL,
  ORDER_DATE      DATE DEFAULT SYSDATE NOT NULL,
  STATUS          VARCHAR2(20 CHAR) DEFAULT 'PENDING' NOT NULL,
  TOTAL_AMOUNT    NUMBER(10, 2) NOT NULL,
  CURRENCY        VARCHAR2(3 CHAR) DEFAULT 'USD' NOT NULL,
  NOTES           VARCHAR2(500 CHAR)
);
```

### 2. Create CHANGE_TRACKING Table

```sql
CREATE TABLE CHANGE_TRACKING (
   ID                  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   TABLE_NAME          VARCHAR2(100 CHAR) NOT NULL,
   TYPE                VARCHAR2(20 CHAR) NOT NULL,
   DATA_CONTENT_TYPE   VARCHAR2(100 CHAR),
   DATA                CLOB CONSTRAINT CHK_JSON_DATA CHECK (DATA IS JSON),
   DATA_BASE64         CLOB,
   OFFSET_DATE_TIME    TIMESTAMP(9) DEFAULT SYSTIMESTAMP NOT NULL
);
```

### 3. Create Trigger on ORDERS

```sql
CREATE OR REPLACE TRIGGER TRG_ORDERS_CHANGE_TRACKING
AFTER INSERT OR UPDATE OR DELETE ON ORDERS
FOR EACH ROW
DECLARE
  v_action_type   VARCHAR2(10);
  v_json_data     CLOB;
  v_data_base64   CLOB;
BEGIN
  IF INSERTING THEN
    v_action_type := 'INSERT';
    v_json_data := TO_CLOB(JSON_OBJECT(
      'ORDER_ID' VALUE :NEW.ORDER_ID,
      'CUSTOMER_ID' VALUE :NEW.CUSTOMER_ID,
      'ORDER_DATE' VALUE TO_CHAR(:NEW.ORDER_DATE, 'YYYY-MM-DD"T"HH24:MI:SS'),
      'STATUS' VALUE :NEW.STATUS,
      'TOTAL_AMOUNT' VALUE TO_CHAR(:NEW.TOTAL_AMOUNT),
      'CURRENCY' VALUE :NEW.CURRENCY,
      'NOTES' VALUE :NEW.NOTES
    ));
    
  ELSIF UPDATING THEN
    v_action_type := 'UPDATE';
    v_json_data := TO_CLOB(JSON_OBJECT(
      'ORDER_ID' VALUE :NEW.ORDER_ID,
      'CUSTOMER_ID' VALUE :NEW.CUSTOMER_ID,
      'ORDER_DATE' VALUE TO_CHAR(:NEW.ORDER_DATE, 'YYYY-MM-DD"T"HH24:MI:SS'),
      'STATUS' VALUE :NEW.STATUS,
      'TOTAL_AMOUNT' VALUE TO_CHAR(:NEW.TOTAL_AMOUNT),
      'CURRENCY' VALUE :NEW.CURRENCY,
      'NOTES' VALUE :NEW.NOTES
    ));
    
  ELSIF DELETING THEN
    v_action_type := 'DELETE';
    v_json_data := TO_CLOB(JSON_OBJECT(
      'ORDER_ID' VALUE :OLD.ORDER_ID,
      'CUSTOMER_ID' VALUE :OLD.CUSTOMER_ID,
      'ORDER_DATE' VALUE TO_CHAR(:OLD.ORDER_DATE, 'YYYY-MM-DD"T"HH24:MI:SS'),
      'STATUS' VALUE :OLD.STATUS,
      'TOTAL_AMOUNT' VALUE TO_CHAR(:OLD.TOTAL_AMOUNT),
      'CURRENCY' VALUE :OLD.CURRENCY,
      'NOTES' VALUE :OLD.NOTES
    ));
  END IF;

  SELECT UTL_RAW.CAST_TO_VARCHAR2(
           UTL_ENCODE.BASE64_ENCODE(UTL_RAW.CAST_TO_RAW(v_json_data))
         )
  INTO v_data_base64
  FROM DUAL;

  INSERT INTO CHANGE_TRACKING (
    TABLE_NAME,
    TYPE,
    DATA_CONTENT_TYPE,
    DATA,
    DATA_BASE64
  ) VALUES (
    'ORDERS',
    v_action_type,
    'application/json',
    v_json_data,
    v_data_base64
  );
END;
/
```

### 4. Test Procedure

```sql
-- Insert test record
INSERT INTO ORDERS (CUSTOMER_ID, TOTAL_AMOUNT) VALUES (101, 150.00);

-- Check change tracking
SELECT * FROM CHANGE_TRACKING WHERE TABLE_NAME = 'ORDERS' ORDER BY OFFSET_DATE_TIME DESC;

-- Update record
UPDATE ORDERS SET STATUS = 'SHIPPED', TOTAL_AMOUNT = 175.00 WHERE CUSTOMER_ID = 101;

-- Check for update
SELECT * FROM CHANGE_TRACKING WHERE TYPE = 'UPDATE' AND TABLE_NAME = 'ORDERS' ORDER BY OFFSET_DATE_TIME DESC;

-- Delete record
DELETE FROM ORDERS WHERE CUSTOMER_ID = 101;

-- Check for delete
SELECT * FROM CHANGE_TRACKING WHERE TYPE = 'DELETE' AND TABLE_NAME = 'ORDERS' ORDER BY OFFSET_DATE_TIME DESC;
```

---

## Kafka Connect Configuration (JDBC Source)c

### Set oracle-source-connector.json (Save it in ./provision/connectors/oracle-source-connector.json)

```json
{
   "name": "oracle-source-connector",
   "config": {
      "connector.class": "io.confluent.connect.jdbc.JdbcSourceConnector",
      "connection.url": "jdbc:oracle:thin:@oracledb:1521/XEPDB1",
      "connection.user": "SYSTEM",
      "connection.password": "MySecurePassword123",
      "table.whitelist": "CHANGE_TRACKING",
      "mode": "timestamp+incrementing",
      "timestamp.column.name": "OFFSET_DATE_TIME",
      "incrementing.column.name": "ID",
      "topic.prefix": "oracle_events_",
      "poll.interval.ms": 5000,
      "key.converter": "org.apache.kafka.connect.storage.StringConverter",
      "value.converter": "org.apache.kafka.connect.json.JsonConverter",
      "value.converter.schemas.enable": false
   }
}
```
### Deploy connector
```bash
   curl -X POST -H "Content-Type: application/json" \
   --data @./provision/connectors/oracle-source-connector.json \
   http://localhost:8083/connectors || true && wait
```

### Check status of the connector
```bash
  curl http://localhost:8083/connectors/oracle-source-connector/status
```

### Check what the connector sees
```batch
curl -s http://localhost:8083/connectors/oracle-source-connector/config | jq
```

### Restart the connector
```bash
curl -X POST http://localhost:8083/connectors/oracle-source-connector/restart
```

### Stop or pause the connector
```bash
   curl -X PUT -H "Content-Type: application/json" \
   --data '{"paused":true}' \
   http://localhost:8083/connectors/oracle-source-connector/pause
```

### Resume the connector
```bash
   curl -X PUT -H "Content-Type: application/json" \
     --data '{"paused":false}' \
     http://localhost:8083/connectors/oracle-source-connector/resume
```

### Delete connector
```bash
  curl -X DELETE http://localhost:8083/connectors/oracle-source-connector
```

### Watch Kafka Connect logs to see connector installation
```batch
   docker logs -f kafka-connect
```

### Check Kafka topics
```batch
docker exec kafka kafka-topics --bootstrap-server localhost:9092 --list | grep oracle
```
### Delete connector offset topic (this forces the connector to start from scratch):
```bash
  docker exec -it kafka kafka-topics --bootstrap-server localhost:9092 --delete --topic docker-connect-offsets
```


